import { clsx } from 'clsx';
import type { ForwardedRef, ForwardRefExoticComponent, ReactElement, RefAttributes } from 'react';
import { Children, cloneElement, forwardRef, isValidElement, useId, useMemo } from 'react';

import type { TextAreaProps } from './text-area.types';
import { TextAreaCompoundContext } from './text-area-context';
import type { TextAreaErrorMessageProps } from './text-area-error-message';
import { TextAreaErrorMessage } from './text-area-error-message';
import type { TextAreaHelperMessageProps } from './text-area-helper-message';
import { TextAreaHelperMessage } from './text-area-helper-message';

type TextAreaComponent = ForwardRefExoticComponent<TextAreaProps & RefAttributes<HTMLTextAreaElement>> & {
  HelperMessage: typeof TextAreaHelperMessage;
  ErrorMessage: typeof TextAreaErrorMessage;
};

function TextAreaInner(
  {
    size = 'medium',
    variant = 'outline',
    isResizable = false,
    autoHeight = false,
    maxHeight,
    isError = false,
    disabled = false,
    height,
    children,
    className,
    ...props
  }: TextAreaProps,
  ref: ForwardedRef<HTMLTextAreaElement>,
) {
  const autoGeneratedId = useId();
  const textAreaPropsForContext = useMemo(
    () => ({
      size,
      variant,
      isError,
    }),
    [size, variant, isError],
  );

  const contextValue = useMemo(
    () => ({
      textAreaProps: textAreaPropsForContext,
      forwardedRef: ref,
    }),
    [textAreaPropsForContext, ref],
  );

  const helperMessageIds: string[] = [];
  const errorIds: string[] = [];
  const describedByBaseId = props.id ?? autoGeneratedId;

  const enhancedChildren = Children.map(children, (child) => {
    if (!isValidElement(child)) {
      return child;
    }

    if (child.type === TextAreaHelperMessage) {
      const helperChild = child as ReactElement<TextAreaHelperMessageProps>;
      const assignedId = helperChild.props.id ?? `${describedByBaseId}-helper-${helperMessageIds.length + 1}`;
      helperMessageIds.push(assignedId);

      return cloneElement(helperChild, { id: assignedId });
    }

    if (child.type === TextAreaErrorMessage && isError) {
      const errorChild = child as ReactElement<TextAreaErrorMessageProps>;
      const assignedId = errorChild.props.id ?? `${describedByBaseId}-error-${errorIds.length + 1}`;
      errorIds.push(assignedId);

      return cloneElement(errorChild, { id: assignedId });
    }

    return child;
  });

  const describedByFromProps = typeof props['aria-describedby'] === 'string' ? props['aria-describedby'] : null;
  const describedByList = [describedByFromProps, ...helperMessageIds, ...errorIds].filter(
    (id): id is string => typeof id === 'string' && id.trim().length > 0,
  );
  const describedByProps =
    describedByList.length > 0
      ? {
          'aria-describedby': describedByList.join(' '),
        }
      : {};

  const shouldMarkInvalid = isError === true || errorIds.length > 0;
  const ariaInvalidFromProps = props['aria-invalid'];
  const ariaInvalidValue = ariaInvalidFromProps != null ? ariaInvalidFromProps : shouldMarkInvalid ? true : null;
  const ariaInvalidProps = ariaInvalidValue == null ? {} : { 'aria-invalid': ariaInvalidValue };

  const mergedTextAreaProps = {
    ...props,
    ...describedByProps,
    ...ariaInvalidProps,
  };

  const isBorderless = variant === 'text';

  const textAreaWrapperClassName = clsx('box-border flex w-full overflow-hidden rounded border', {
    // outline variant
    'border-supportError': !isBorderless && isError && !disabled,
    'border-uiBorder02': !isBorderless && !isError && !disabled,
    'hover:border-hoverInput': !isBorderless && !disabled && !isError,
    'hover:focus-within:border-activeInput': !isBorderless && !isError,
    'focus-within:border-activeInput': !isBorderless && !isError,
    'bg-disabled02 border-disabled01': !isBorderless && disabled,
    // text variant
    'border-transparent': isBorderless,
  });

  const textAreaClassName = clsx(
    'w-full border-none bg-uiBackground01 outline-none placeholder:text-textPlaceholder',
    className,
    {
      // outline: 従来の padding
      'typography-body14regular px-2 py-2': !isBorderless && size === 'medium',
      'typography-body16regular px-3 py-2': !isBorderless && size === 'large',
      // text: padding なし
      'typography-body14regular': isBorderless && size === 'medium',
      'typography-body16regular': isBorderless && size === 'large',
      'disabled:text-textPlaceholder': !isBorderless,
      'disabled:text-disabled01': isBorderless,
      'field-sizing-content': autoHeight,
      'text-text01': !isError,
      'text-supportError': !isBorderless && isError,
      'text-supportError placeholder:text-supportErrorLight': isBorderless && isError && !disabled,
      'bg-disabled02': !isBorderless && disabled,
      'resize-none': !isResizable,
    },
  );

  const hasHeight = height != null && String(height).trim().length > 0;

  const textAreaElement = (
    <div
      className={textAreaWrapperClassName}
      style={{
        ...{ maxHeight },
        // height/minHeight はラッパに適用し、外形を揃える
        ...(!autoHeight && hasHeight ? { height } : {}),
        ...(autoHeight && hasHeight ? { minHeight: height } : {}),
      }}
    >
      <textarea
        ref={ref}
        className={textAreaClassName}
        {...mergedTextAreaProps}
        disabled={disabled}
        style={{
          height: autoHeight ? 'auto' : '100%',
          minHeight: autoHeight && hasHeight ? '100%' : 'auto',
        }}
      />
    </div>
  );

  const stackedChildren = enhancedChildren == null ? [] : Children.toArray(enhancedChildren);
  const hasMessageChildren = stackedChildren.length > 0;

  if (!hasMessageChildren) {
    return <TextAreaCompoundContext.Provider value={contextValue}>{textAreaElement}</TextAreaCompoundContext.Provider>;
  }

  return (
    <TextAreaCompoundContext.Provider value={contextValue}>
      <div className="flex flex-col gap-2">
        {textAreaElement}
        {stackedChildren}
      </div>
    </TextAreaCompoundContext.Provider>
  );
}

const attachStatics = <T extends TextAreaComponent>(component: T): T => {
  component.HelperMessage = TextAreaHelperMessage;
  component.ErrorMessage = TextAreaErrorMessage;
  component.displayName = 'TextArea';

  return component;
};

const TextAreaBase = forwardRef<HTMLTextAreaElement, TextAreaProps>(function TextAreaBase(props, ref) {
  return TextAreaInner(props, ref);
}) as TextAreaComponent;

const TextArea = attachStatics(TextAreaBase);

export { TextArea };
