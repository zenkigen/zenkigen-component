import { clsx } from 'clsx';
import type { ForwardedRef, ForwardRefExoticComponent, ReactElement, RefAttributes } from 'react';
import { Children, cloneElement, forwardRef, isValidElement, useId, useMemo } from 'react';

import { IconButton } from '../icon-button';
import type { TextInputInternalProps, TextInputProps } from './text-input.types';
import { TextInputCompoundContext } from './text-input-context';
import type { TextInputErrorMessageProps } from './text-input-error-message';
import { TextInputErrorMessage } from './text-input-error-message';
import type { TextInputHelperMessageProps } from './text-input-helper-message';
import { TextInputHelperMessage } from './text-input-helper-message';

type TextInputComponent = ForwardRefExoticComponent<TextInputProps & RefAttributes<HTMLInputElement>> & {
  HelperMessage: typeof TextInputHelperMessage;
  ErrorMessage: typeof TextInputErrorMessage;
};

type TextInputInternalComponent = ForwardRefExoticComponent<
  TextInputInternalProps & RefAttributes<HTMLInputElement>
> & {
  HelperMessage: typeof TextInputHelperMessage;
  ErrorMessage: typeof TextInputErrorMessage;
};

function TextInputInner(
  {
    size = 'medium',
    isError = false,
    disabled = false,
    onClickClearButton,
    after,
    children,
    ...props
  }: TextInputInternalProps,
  ref: ForwardedRef<HTMLInputElement>,
) {
  const autoGeneratedId = useId();
  const { className: _className, ...restInputProps } = props as typeof props & {
    className?: string;
  };
  const inputPropsForContext = useMemo(
    () => ({
      ...restInputProps,
      size,
      isError,
      disabled,
      onClickClearButton,
      after,
    }),
    [restInputProps, size, isError, disabled, onClickClearButton, after],
  );

  const contextValue = useMemo(
    () => ({
      inputProps: inputPropsForContext,
      forwardedRef: ref,
    }),
    [inputPropsForContext, ref],
  );

  const helperMessageIds: string[] = [];
  const errorIds: string[] = [];
  const describedByBaseId = restInputProps.id ?? autoGeneratedId;

  const enhancedChildren = Children.map(children, (child) => {
    if (!isValidElement(child)) {
      return child;
    }

    if (child.type === TextInputHelperMessage) {
      const helperChild = child as ReactElement<TextInputHelperMessageProps>;
      const assignedId = helperChild.props.id ?? `${describedByBaseId}-helper-${helperMessageIds.length + 1}`;
      helperMessageIds.push(assignedId);

      return cloneElement(helperChild, { id: assignedId });
    }

    if (child.type === TextInputErrorMessage && isError) {
      const errorChild = child as ReactElement<TextInputErrorMessageProps>;
      const assignedId = errorChild.props.id ?? `${describedByBaseId}-error-${errorIds.length + 1}`;
      errorIds.push(assignedId);

      return cloneElement(errorChild, { id: assignedId });
    }

    return child;
  });

  const describedByFromProps =
    typeof restInputProps['aria-describedby'] === 'string' ? restInputProps['aria-describedby'] : null;
  const describedByList = [describedByFromProps, ...helperMessageIds, ...errorIds].filter(
    (id): id is string => typeof id === 'string' && id.trim().length > 0,
  );
  const describedByProps =
    describedByList.length > 0
      ? {
          'aria-describedby': describedByList.join(' '),
        }
      : {};

  const shouldMarkInvalid = isError === true || errorIds.length > 0;
  const ariaInvalidFromProps = restInputProps['aria-invalid'];
  const ariaInvalidValue = ariaInvalidFromProps != null ? ariaInvalidFromProps : shouldMarkInvalid ? true : null;
  const ariaInvalidProps = ariaInvalidValue == null ? {} : { 'aria-invalid': ariaInvalidValue };

  const mergedInputProps = {
    ...restInputProps,
    ...describedByProps,
    ...ariaInvalidProps,
    disabled,
  };

  const isShowClearButton = !!onClickClearButton && restInputProps.value.length !== 0 && !disabled;
  const hasTrailingElement = isShowClearButton || after != null;

  const inputWrapClasses = clsx('relative flex items-center gap-2 overflow-hidden rounded border', {
    'border-uiBorder02': !isError && !disabled,
    'border-supportError': isError && !disabled,
    'hover:border-hoverInput': !disabled && !isError,
    'hover:focus-within:border-activeInput': !isError,
    'focus-within:border-activeInput': !isError,
    'bg-disabled02 border-disabled01': disabled,
    'pr-2': size === 'medium' && hasTrailingElement,
    'pr-3': size === 'large' && hasTrailingElement,
  });

  const inputClasses = clsx('flex-1 outline-none placeholder:text-textPlaceholder disabled:text-textPlaceholder', {
    ['typography-label14regular min-h-8 px-2']: size === 'medium',
    ['typography-label16regular min-h-10 px-3']: size === 'large',
    'text-text01': !isError,
    'text-supportError': isError,
    'pr-0': hasTrailingElement,
  });

  const inputElement = (
    <div className={inputWrapClasses}>
      <input ref={ref} size={1} className={inputClasses} {...mergedInputProps} />
      {after}
      {isShowClearButton && <IconButton variant="text" icon="close" size="small" onClick={onClickClearButton} />}
    </div>
  );

  const stackedChildren = enhancedChildren == null ? [] : Children.toArray(enhancedChildren);
  const hasMessageChildren = stackedChildren.length > 0;

  if (!hasMessageChildren) {
    return <TextInputCompoundContext.Provider value={contextValue}>{inputElement}</TextInputCompoundContext.Provider>;
  }

  return (
    <TextInputCompoundContext.Provider value={contextValue}>
      <div className="flex flex-col gap-2">
        {inputElement}
        {stackedChildren}
      </div>
    </TextInputCompoundContext.Provider>
  );
}

const attachStatics = <T extends TextInputComponent | TextInputInternalComponent>(component: T): T => {
  component.HelperMessage = TextInputHelperMessage;
  component.ErrorMessage = TextInputErrorMessage;
  component.displayName = 'TextInput';

  return component;
};

const TextInputPublic = forwardRef<HTMLInputElement, TextInputProps>(function TextInputPublic(props, ref) {
  return TextInputInner(props as TextInputInternalProps, ref);
}) as TextInputComponent;

const InternalTextInputBase = forwardRef<HTMLInputElement, TextInputInternalProps>(
  function InternalTextInputBase(props, ref) {
    return TextInputInner(props, ref);
  },
) as TextInputInternalComponent;

const TextInput = attachStatics(TextInputPublic);
const InternalTextInput = attachStatics(InternalTextInputBase);

export { InternalTextInput, TextInput };
