import { clsx } from 'clsx';
import type { MouseEventHandler, ReactElement } from 'react';
import {
  Children,
  cloneElement,
  isValidElement,
  useCallback,
  useEffect,
  useId,
  useMemo,
  useRef,
  useState,
} from 'react';
import { DayPicker, type Matcher, type MonthCaptionProps, useDayPicker } from 'react-day-picker';

import { InternalButton } from '../button/button';
import { Icon } from '../icon';
import { IconButton } from '../icon-button';
import { Popover } from '../popover';
import type { DatePickerProps, DatePickerTimeZone } from './date-picker.types';
import { DatePickerCompoundContext } from './date-picker-context';
import type { DatePickerErrorMessageProps } from './date-picker-error-message';
import { DatePickerErrorMessage } from './date-picker-error-message';
import {
  createDateFromKey,
  formatDateKey,
  formatDisplayDate,
  formatLocalDateKey,
  getMonthStartDate,
  normalizeDate,
} from './date-picker-utils';

type DatePickerComponent = ((props: DatePickerProps) => ReactElement) & {
  ErrorMessage: typeof DatePickerErrorMessage;
  displayName?: string;
};

const dayPickerClassNames = {
  months: 'flex flex-col gap-2',
  month: 'px-2',
  table: 'w-full border-separate border-spacing-0.5',
  head_cell: 'h-7 w-7 text-center typography-label12bold text-text02',
  row: 'h-7',
  cell: 'p-0 text-center',
  day: clsx(
    'typography-label12bold flex size-7 items-center justify-center rounded-full border border-transparent',
    'text-interactive02 hover:border-selectedUiBorder hover:bg-uiBackgroundBlue hover:text-text02',
    'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-interactive01',
  ),
  day_selected: 'bg-uiBackgroundBlue border-selectedUiBorder text-text02',
  day_today: 'bg-interactive01 border-selectedUiBorder text-textOnColor',
  day_outside: 'text-interactive04 pointer-events-none',
  day_disabled: 'text-interactive04 pointer-events-none',
};

const formatMonthLabel = (date: Date, timeZone: DatePickerTimeZone) => {
  const [year, month] = formatDateKey(date, timeZone).split('-');

  return `${year}年${month}月`;
};

export const DatePicker: DatePickerComponent = ({
  value,
  onChange,
  isDisabled = false,
  isError = false,
  min,
  max,
  placeholder = '日付を選択',
  size = 'medium',
  timeZone = 'UTC',
  children,
  onClick,
  type,
  ...restProps
}: DatePickerProps) => {
  const autoGeneratedId = useId();
  const describedByBaseId = restProps.id ?? autoGeneratedId;
  const [isOpen, setIsOpen] = useState(false);
  const [displayMonth, setDisplayMonth] = useState(() => getMonthStartDate(value ?? new Date(), timeZone));
  const calendarRef = useRef<HTMLDivElement>(null);

  const normalizedSelected = useMemo(
    () => (value == null ? undefined : normalizeDate(value, timeZone)),
    [value, timeZone],
  );
  const minDate = useMemo(() => (min == null ? undefined : normalizeDate(min, timeZone)), [min, timeZone]);
  const maxDate = useMemo(() => (max == null ? undefined : normalizeDate(max, timeZone)), [max, timeZone]);
  const currentMonthKey = useMemo(() => formatDateKey(displayMonth, timeZone).slice(0, 7), [displayMonth, timeZone]);
  const isOutsideMonth = useCallback(
    (date: Date) => formatDateKey(date, timeZone).slice(0, 7) !== currentMonthKey,
    [currentMonthKey, timeZone],
  );
  const disabledDays = useMemo<Matcher[]>(
    () => [isOutsideMonth, ...(minDate ? [{ before: minDate }] : []), ...(maxDate ? [{ after: maxDate }] : [])],
    [isOutsideMonth, minDate, maxDate],
  );
  const todayForCalendar = useMemo(() => createDateFromKey(formatLocalDateKey(), timeZone), [timeZone]);

  useEffect(() => {
    if (value == null) {
      setDisplayMonth(getMonthStartDate(new Date(), timeZone));

      return;
    }

    setDisplayMonth(getMonthStartDate(value, timeZone));
  }, [value, timeZone]);

  useEffect(() => {
    if (!isOpen) {
      return;
    }

    const frame = requestAnimationFrame(() => {
      const container = calendarRef.current;
      if (!container) {
        return;
      }

      const selected = container.querySelector<HTMLButtonElement>('button[aria-selected="true"]');
      const today = container.querySelector<HTMLButtonElement>('button[aria-current="date"]');
      const focusTarget = selected ?? today;

      focusTarget?.focus({ preventScroll: true });
    });

    return () => cancelAnimationFrame(frame);
  }, [displayMonth, isOpen, timeZone, value]);

  useEffect(() => {
    if (isDisabled) {
      setIsOpen(false);
    }
  }, [isDisabled]);

  const handleTriggerClick: MouseEventHandler<HTMLButtonElement> = (event) => {
    if (isDisabled) {
      event.preventDefault();

      return;
    }

    onClick?.(event);
    setIsOpen((prev) => !prev);
  };

  const handleClose = () => {
    setIsOpen(false);
  };

  const handleSelect = (selected: Date | undefined) => {
    if (!selected) {
      return;
    }

    onChange(normalizeDate(selected, timeZone));
    setIsOpen(false);
  };

  const handleClear = () => {
    onChange(null);
    setIsOpen(false);
  };

  const handleClickToday = () => {
    const todayKey = formatLocalDateKey(new Date());
    const todayInTimeZone = createDateFromKey(todayKey, timeZone);
    setDisplayMonth(getMonthStartDate(todayInTimeZone, timeZone));
  };

  const formatters = useMemo(() => {
    const weekdayFormatter = new Intl.DateTimeFormat('ja-JP', { weekday: 'short', timeZone });

    return {
      formatCaption: (date: Date) => formatMonthLabel(date, timeZone),
      formatDay: (date: Date) => {
        const [, , day] = formatDateKey(date, timeZone).split('-');

        return String(Number(day));
      },
      formatWeekdayName: (date: Date) => weekdayFormatter.format(date),
    };
  }, [timeZone]);

  const iconSize = size === 'large' ? 'medium' : 'small';
  const displayText = value ? formatDisplayDate(value, timeZone) : placeholder;
  const displayTextClasses = clsx('min-w-0 flex-1 truncate', !value && 'text-textPlaceholder');

  const errorIds: string[] = [];

  const enhancedChildren = Children.map(children, (child) => {
    if (!isValidElement(child)) {
      return child;
    }

    if (child.type === DatePickerErrorMessage && isError) {
      const errorChild = child as ReactElement<DatePickerErrorMessageProps>;
      const assignedId = errorChild.props.id ?? `${describedByBaseId}-error-${errorIds.length + 1}`;
      errorIds.push(assignedId);

      return cloneElement(errorChild, { id: assignedId });
    }

    return child;
  });

  const describedByFromProps = typeof restProps['aria-describedby'] === 'string' ? restProps['aria-describedby'] : null;
  const describedByList = [describedByFromProps, ...errorIds].filter(
    (id): id is string => typeof id === 'string' && id.trim().length > 0,
  );
  const describedByProps =
    describedByList.length > 0
      ? {
          'aria-describedby': describedByList.join(' '),
        }
      : {};

  const shouldMarkInvalid = isError === true || errorIds.length > 0;
  const ariaInvalidFromProps = restProps['aria-invalid'];
  const ariaInvalidValue = ariaInvalidFromProps != null ? ariaInvalidFromProps : shouldMarkInvalid ? true : null;
  const ariaInvalidProps = ariaInvalidValue == null ? {} : { 'aria-invalid': ariaInvalidValue };

  const mergedButtonProps = {
    ...restProps,
    ...describedByProps,
    ...ariaInvalidProps,
  };

  const contextValue = useMemo(
    () => ({
      size,
      isError,
    }),
    [isError, size],
  );

  const CustomMonthCaption = ({ calendarMonth, className, ...props }: MonthCaptionProps) => {
    const { goToMonth, nextMonth, previousMonth } = useDayPicker();
    const captionMonth = calendarMonth.date;

    return (
      <div className={clsx('flex h-7 items-center justify-between px-2', className)} {...props}>
        <IconButton
          icon="angle-left"
          size="small"
          variant="text"
          isNoPadding
          isDisabled={!previousMonth}
          aria-label="前の月"
          onClick={() => previousMonth && goToMonth(previousMonth)}
        />
        <span className="typography-label12bold text-text02">{formatMonthLabel(captionMonth, timeZone)}</span>
        <IconButton
          icon="angle-right"
          size="small"
          variant="text"
          isNoPadding
          isDisabled={!nextMonth}
          aria-label="次の月"
          onClick={() => nextMonth && goToMonth(nextMonth)}
        />
      </div>
    );
  };

  const popoverContent = (
    <Popover isOpen={isOpen} placement="bottom-start" onClose={handleClose}>
      <Popover.Trigger>
        <InternalButton
          {...mergedButtonProps}
          type={type ?? 'button'}
          size={size}
          variant={isError ? 'outlineDanger' : 'outline'}
          isDisabled={isDisabled}
          before={<Icon name="calendar" size={iconSize} />}
          onClick={handleTriggerClick}
        >
          <span className={displayTextClasses}>{displayText}</span>
        </InternalButton>
      </Popover.Trigger>
      <Popover.Content>
        <div ref={calendarRef} className="w-[224px] rounded bg-uiBackground01 shadow-floatingShadow">
          <div className="pt-2">
            <DayPicker
              mode="single"
              showOutsideDays
              hideNavigation
              weekStartsOn={0}
              timeZone={timeZone}
              month={displayMonth}
              onMonthChange={setDisplayMonth}
              selected={normalizedSelected}
              onSelect={handleSelect}
              today={todayForCalendar}
              disabled={disabledDays}
              classNames={dayPickerClassNames}
              formatters={formatters}
              components={{ MonthCaption: CustomMonthCaption }}
            />
          </div>
          <div className="flex h-10 items-center justify-between border-t border-uiBorder01 bg-uiBackground01 px-2">
            <IconButton
              icon="calendar-today"
              size="medium"
              variant="text"
              isNoPadding
              aria-label="今日に戻る"
              onClick={handleClickToday}
            />
            <button type="button" className="typography-label14regular text-interactive02" onClick={handleClear}>
              クリア
            </button>
          </div>
        </div>
      </Popover.Content>
    </Popover>
  );

  const stackedChildren = enhancedChildren == null ? [] : Children.toArray(enhancedChildren);
  const hasMessageChildren = stackedChildren.length > 0;

  if (!hasMessageChildren) {
    return (
      <DatePickerCompoundContext.Provider value={contextValue}>{popoverContent}</DatePickerCompoundContext.Provider>
    );
  }

  return (
    <DatePickerCompoundContext.Provider value={contextValue}>
      <div className="flex flex-col gap-2">
        {popoverContent}
        {stackedChildren}
      </div>
    </DatePickerCompoundContext.Provider>
  );
};

DatePicker.ErrorMessage = DatePickerErrorMessage;
DatePicker.displayName = 'DatePicker';
