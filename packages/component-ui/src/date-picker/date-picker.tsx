import 'react-day-picker/style.css';

import { clsx } from 'clsx';
import type { CSSProperties, MouseEventHandler, ReactElement } from 'react';
import {
  Children,
  cloneElement,
  isValidElement,
  useCallback,
  useEffect,
  useId,
  useMemo,
  useRef,
  useState,
} from 'react';
import type { DayButtonProps, MonthCaptionProps, WeekdayProps } from 'react-day-picker';
import { DayPicker, getDefaultClassNames, useDayPicker } from 'react-day-picker';

import { Button, InternalButton } from '../button/button';
import { Icon } from '../icon';
import { IconButton } from '../icon-button';
import { Popover } from '../popover';
import type { DatePickerProps } from './date-picker.types';
import { DatePickerCompoundContext } from './date-picker-context';
import type { DatePickerErrorMessageProps } from './date-picker-error-message';
import { DatePickerErrorMessage } from './date-picker-error-message';
import {
  createDateFromKey,
  createLocalDateFromKey,
  formatDateKey,
  formatDisplayDate,
  formatLocalDateKey,
  getMonthStartDate,
} from './date-picker-utils';

type DatePickerComponent = ((props: DatePickerProps) => ReactElement) & {
  ErrorMessage: typeof DatePickerErrorMessage;
  displayName?: string;
};

const defaultDayPickerClassNames = getDefaultClassNames();
const dayPickerStyle = {
  '--rdp-font-family': "Arial, 'Noto Sans JP', sans-serif",
  '--rdp-nav-height': '28px',
  '--rdp-day-font': "700 12px/1 'Arial', 'Noto Sans JP', sans-serif",
  '--rdp-selected-font': "700 12px/1 'Arial', 'Noto Sans JP', sans-serif",
  '--rdp-weekday-font': "700 12px/1 'Arial', 'Noto Sans JP', sans-serif",
  '--rdp-day-width': '30px',
  '--rdp-day-height': '30px',
  '--rdp-day_button-width': '28px',
  '--rdp-day_button-height': '28px',
  '--rdp-day_button-border': '1px solid black',
  '--rdp-weekday-padding': '0px',
} as CSSProperties;

const dayPickerClassNames = {
  // ...defaultDayPickerClassNames,
  month: clsx(defaultDayPickerClassNames.month, 'flex flex-col gap-0.5 p-2'),
  // month_grid: clsx(defaultDayPickerClassNames.month_grid, 'w-full'),
  // weekday: defaultDayPickerClassNames.weekday,
  // week: clsx(defaultDayPickerClassNames.week, 'h-7'),
  // day: clsx(defaultDayPickerClassNames.day, 'p-0.5 text-center'),
  // day_button: defaultDayPickerClassNames.day_button,
  // selected: '',
  // disabled: '',
  // outside: '',
  // today: '',
};

const CustomDayButton = ({ day, modifiers, className, ...buttonProps }: DayButtonProps) => {
  const isSelected = Boolean(modifiers.selected);
  const isDisabled = Boolean(modifiers.disabled);
  const now = new Date();
  const isToday =
    day.date.getFullYear() === now.getFullYear() &&
    day.date.getMonth() === now.getMonth() &&
    day.date.getDate() === now.getDate();

  return (
    <button
      type="button"
      {...buttonProps}
      className={clsx(
        className,
        'relative grid size-full place-items-center rounded-full !border !border-solid',
        'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-interactive01',
        !isSelected && '!border-transparent',
        !isToday && !isDisabled && '!text-interactive02 hover:!bg-hoverUi',
        isToday && !isSelected && '!border-selectedUiBorder !bg-interactive01 !text-textOnColor',
        isDisabled && '!cursor-not-allowed !text-interactive04',
        isSelected && '!border-selectedUiBorder !bg-uiBackgroundBlue',
      )}
    >
      {buttonProps.children}
    </button>
  );
};

const CustomWeekday = ({ className, children, ...props }: WeekdayProps) => {
  return (
    <th
      {...props}
      className={clsx(className, 'm-0 flex size-7 items-center justify-center p-0 text-center text-text02')}
    >
      {children}
    </th>
  );
};

const formatMonthLabel = (date: Date) => {
  const [year, month] = formatLocalDateKey(date).split('-');

  return `${year}年${month}月`;
};

export const DatePicker: DatePickerComponent = ({
  value,
  onChange,
  isDisabled = false,
  isError = false,
  min,
  max,
  placeholder = '日付を選択',
  size = 'medium',
  timeZone = 'UTC',
  children,
  onClick,
  type,
  ...restProps
}: DatePickerProps) => {
  const autoGeneratedId = useId();
  const describedByBaseId = restProps.id ?? autoGeneratedId;
  const [isOpen, setIsOpen] = useState(false);
  const [displayMonth, setDisplayMonth] = useState(() => {
    if (value == null) {
      const todayKey = formatLocalDateKey(new Date());

      return createLocalDateFromKey(`${todayKey.slice(0, 7)}-01`);
    }

    return getMonthStartDate(value, timeZone);
  });
  const calendarRef = useRef<HTMLDivElement>(null);

  const selectedKey = useMemo(() => (value == null ? null : formatDateKey(value, timeZone)), [value, timeZone]);
  const selectedDate = useMemo(
    () => (selectedKey == null ? void 0 : createLocalDateFromKey(selectedKey)),
    [selectedKey],
  );
  const minKey = useMemo(() => (min == null ? null : formatDateKey(min, timeZone)), [min, timeZone]);
  const maxKey = useMemo(() => (max == null ? null : formatDateKey(max, timeZone)), [max, timeZone]);
  const currentMonthKey = useMemo(() => formatLocalDateKey(displayMonth).slice(0, 7), [displayMonth]);
  const isOutsideMonth = useCallback(
    (date: Date) => formatLocalDateKey(date).slice(0, 7) !== currentMonthKey,
    [currentMonthKey],
  );
  const disabledDays = useCallback(
    (date: Date) => {
      const dateKey = formatLocalDateKey(date);
      if (isOutsideMonth(date)) {
        return true;
      }
      if (minKey != null && dateKey < minKey) {
        return true;
      }
      if (maxKey != null && dateKey > maxKey) {
        return true;
      }

      return false;
    },
    [isOutsideMonth, maxKey, minKey],
  );
  const todayForCalendar = useMemo(() => createLocalDateFromKey(formatLocalDateKey()), []);

  useEffect(() => {
    if (value == null) {
      const todayKey = formatLocalDateKey(new Date());
      setDisplayMonth(createLocalDateFromKey(`${todayKey.slice(0, 7)}-01`));

      return;
    }

    setDisplayMonth(getMonthStartDate(value, timeZone));
  }, [value, timeZone]);

  useEffect(() => {
    if (!isOpen) {
      return;
    }

    const frame = requestAnimationFrame(() => {
      const container = calendarRef.current;
      if (!container) {
        return;
      }

      const selected = container.querySelector<HTMLButtonElement>('button[aria-selected="true"]');
      const today = container.querySelector<HTMLButtonElement>('button[aria-current="date"]');
      const focusTarget = selected ?? today;

      focusTarget?.focus({ preventScroll: true });
    });

    return () => cancelAnimationFrame(frame);
  }, [displayMonth, isOpen, value]);

  useEffect(() => {
    if (isDisabled) {
      setIsOpen(false);
    }
  }, [isDisabled]);

  const handleTriggerClick: MouseEventHandler<HTMLButtonElement> = (event) => {
    if (isDisabled) {
      event.preventDefault();

      return;
    }

    onClick?.(event);
    setIsOpen((prev) => !prev);
  };

  const handleClose = () => {
    setIsOpen(false);
  };

  const handleSelect = (selected: Date | undefined) => {
    if (!selected) {
      return;
    }

    const selectedKey = formatLocalDateKey(selected);
    onChange(createDateFromKey(selectedKey, timeZone));
    setIsOpen(false);
  };

  const handleClear = () => {
    onChange(null);
    setIsOpen(false);
  };

  const handleClickToday = () => {
    const todayKey = formatLocalDateKey(new Date());
    setDisplayMonth(createLocalDateFromKey(`${todayKey.slice(0, 7)}-01`));
  };

  const formatters = useMemo(() => {
    const weekdayFormatter = new Intl.DateTimeFormat('ja-JP', { weekday: 'short' });

    return {
      formatCaption: (date: Date) => formatMonthLabel(date),
      formatDay: (date: Date) => String(date.getDate()),
      formatWeekdayName: (date: Date) => weekdayFormatter.format(date),
    };
  }, []);

  const iconSize = size === 'large' ? 'medium' : 'small';
  const displayText = value ? formatDisplayDate(value, timeZone) : placeholder;
  const displayTextClasses = 'min-w-0 flex-1 truncate';

  const errorIds: string[] = [];

  const enhancedChildren = Children.map(children, (child) => {
    if (!isValidElement(child)) {
      return child;
    }

    if (child.type === DatePickerErrorMessage && isError) {
      const errorChild = child as ReactElement<DatePickerErrorMessageProps>;
      const assignedId = errorChild.props.id ?? `${describedByBaseId}-error-${errorIds.length + 1}`;
      errorIds.push(assignedId);

      return cloneElement(errorChild, { id: assignedId });
    }

    return child;
  });

  const describedByFromProps = typeof restProps['aria-describedby'] === 'string' ? restProps['aria-describedby'] : null;
  const describedByList = [describedByFromProps, ...errorIds].filter(
    (id): id is string => typeof id === 'string' && id.trim().length > 0,
  );
  const describedByProps =
    describedByList.length > 0
      ? {
          'aria-describedby': describedByList.join(' '),
        }
      : {};

  const shouldMarkInvalid = isError === true || errorIds.length > 0;
  const ariaInvalidFromProps = restProps['aria-invalid'];
  const ariaInvalidValue = ariaInvalidFromProps != null ? ariaInvalidFromProps : shouldMarkInvalid ? true : null;
  const ariaInvalidProps = ariaInvalidValue == null ? {} : { 'aria-invalid': ariaInvalidValue };

  const mergedButtonProps = {
    ...restProps,
    ...describedByProps,
    ...ariaInvalidProps,
  };

  const contextValue = useMemo(
    () => ({
      size,
      isError,
    }),
    [isError, size],
  );

  const CustomMonthCaption = ({ calendarMonth, className, displayIndex, ...props }: MonthCaptionProps) => {
    const { goToMonth, nextMonth, previousMonth } = useDayPicker();
    const captionMonth = calendarMonth.date;

    return (
      <div className={clsx('flex h-7 items-center justify-between px-0.5', className)} {...props}>
        <IconButton
          icon="angle-left"
          size="small"
          variant="text"
          isDisabled={!previousMonth}
          aria-label="前の月"
          onClick={() => previousMonth && goToMonth(previousMonth)}
        />
        <span className="typography-label12bold text-text02">{formatMonthLabel(captionMonth)}</span>
        <IconButton
          icon="angle-right"
          size="small"
          variant="text"
          isDisabled={!nextMonth}
          aria-label="次の月"
          onClick={() => nextMonth && goToMonth(nextMonth)}
        />
      </div>
    );
  };

  const popoverContent = (
    <Popover isOpen={isOpen} placement="bottom-start" onClose={handleClose}>
      <Popover.Trigger>
        <InternalButton
          {...mergedButtonProps}
          type={type ?? 'button'}
          size={size}
          variant={isError ? 'outlineDanger' : 'outline'}
          isDisabled={isDisabled}
          before={<Icon name="calendar" size={iconSize} />}
          onClick={handleTriggerClick}
        >
          <span className={displayTextClasses}>{displayText}</span>
        </InternalButton>
      </Popover.Trigger>
      <Popover.Content>
        <div ref={calendarRef} className="rounded bg-uiBackground01 shadow-floatingShadow" aria-label="日付選択">
          <DayPicker
            mode="single"
            showOutsideDays
            hideNavigation
            weekStartsOn={0}
            style={dayPickerStyle}
            month={displayMonth}
            onMonthChange={setDisplayMonth}
            selected={selectedDate}
            onSelect={handleSelect}
            today={todayForCalendar}
            disabled={disabledDays}
            classNames={dayPickerClassNames}
            formatters={formatters}
            fixedWeeks
            components={{ MonthCaption: CustomMonthCaption, DayButton: CustomDayButton, Weekday: CustomWeekday }}
          />
          <div className="flex items-center justify-between border-t border-uiBorder01 px-2 py-1">
            <IconButton
              icon="calendar-today"
              size="medium"
              variant="text"
              aria-label="今日に戻る"
              iconAccentColor="supportInfo"
              onClick={handleClickToday}
            />
            <Button type="button" size="small" variant="text" onClick={handleClear}>
              クリア
            </Button>
          </div>
        </div>
      </Popover.Content>
    </Popover>
  );

  const stackedChildren = enhancedChildren == null ? [] : Children.toArray(enhancedChildren);
  const hasMessageChildren = stackedChildren.length > 0;

  if (!hasMessageChildren) {
    return (
      <DatePickerCompoundContext.Provider value={contextValue}>{popoverContent}</DatePickerCompoundContext.Provider>
    );
  }

  return (
    <DatePickerCompoundContext.Provider value={contextValue}>
      <div className="flex flex-col gap-2">
        {popoverContent}
        {stackedChildren}
      </div>
    </DatePickerCompoundContext.Provider>
  );
};

DatePicker.ErrorMessage = DatePickerErrorMessage;
DatePicker.displayName = 'DatePicker';
